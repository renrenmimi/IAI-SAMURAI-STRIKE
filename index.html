<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>IAI: SAMURAI STRIKE | 居合·一闪</title>
    <style>
      /* ==========================================================================
       ZEN MINIMALIST CSS - THE WAY OF THE SAMURAI
       ========================================================================== */
      :root {
        --bg-color: #050505;
        --ink-color: #1a1a1a;
        --blood-red: #c0392b;
        --text-color: #e0e0e0;
        --font-serif: "Georgia", "Times New Roman", serif;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      body,
      html {
        width: 100%;
        height: 100%;
        background-color: var(--bg-color);
        overflow: hidden;
        font-family: var(--font-serif);
        color: var(--text-color);
        touch-action: none;
      }

      /* 底层 Canvas：雨滴与血迹 */
      #bg-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none;
      }

      /* 游戏主容器 */
      #game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        z-index: 10;
      }

      /* 玩家区域 */
      .player-zone {
        flex: 1;
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        pointer-events: auto;
        transition: background 0.5s;
      }
      #zone-p1 {
        border-right: 1px solid rgba(255, 255, 255, 0.03);
      }

      /* 败者错位滑落动画 (核心视觉卖点) */
      .sliced-zone {
        animation: sliceDrop 1.5s cubic-bezier(0.1, 0.9, 0.2, 1) forwards;
        filter: grayscale(1) brightness(0.3);
        pointer-events: none;
      }
      @keyframes sliceDrop {
        0% {
          clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
          transform: translateY(0) rotate(0);
        }
        5% {
          clip-path: polygon(0 30%, 100% 50%, 100% 100%, 0 100%);
          transform: translateY(2px) translateX(2px) rotate(1deg);
        }
        100% {
          clip-path: polygon(0 30%, 100% 50%, 100% 100%, 0 100%);
          transform: translateY(60px) translateX(15px) rotate(3deg);
        }
      }

      /* UI 文本 */
      .status-text {
        font-size: 3vh;
        letter-spacing: 0.5vw;
        text-transform: uppercase;
        opacity: 0.3;
        transition: all 0.3s;
        pointer-events: none;
        text-align: center;
      }
      .status-text.active {
        opacity: 1;
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        transform: scale(1.05);
      }
      .status-text.error {
        color: var(--blood-red);
        opacity: 1;
        text-shadow: 0 0 20px var(--blood-red);
      }
      .instruction {
        font-size: 1.5vh;
        opacity: 0.2;
        margin-top: 20px;
        font-family: monospace;
        letter-spacing: 2px;
      }

      /* 一闪的刀光斜线 */
      #slash-line {
        position: absolute;
        top: 50%;
        left: -20%;
        width: 140%;
        height: 2px;
        background: #fff;
        z-index: 100;
        pointer-events: none;
        transform: translateY(-50%) rotate(10deg) scaleX(0);
        transform-origin: center;
        box-shadow:
          0 0 10px #fff,
          0 0 30px #fff;
        opacity: 0;
      }
      .anim-slash {
        animation: slashAnim 0.6s cubic-bezier(0.075, 0.82, 0.165, 1) forwards;
      }
      @keyframes slashAnim {
        0% {
          transform: translateY(-50%) rotate(10deg) scaleX(0);
          opacity: 1;
        }
        10% {
          transform: translateY(-50%) rotate(10deg) scaleX(1);
          opacity: 1;
          height: 4px;
        }
        100% {
          transform: translateY(-50%) rotate(10deg) scaleX(1);
          opacity: 0;
          height: 0px;
        }
      }

      /* 屏幕闪白/反色 */
      #flash-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #fff;
        z-index: 90;
        opacity: 0;
        pointer-events: none;
      }
      .anim-flash {
        animation: flashWhite 0.8s ease-out forwards;
      }
      @keyframes flashWhite {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }

      /* 中央信息与记分板 */
      #center-hud {
        position: absolute;
        top: 10%;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        z-index: 50;
        pointer-events: none;
        width: 100%;
      }
      .score-board {
        font-size: 4vh;
        letter-spacing: 2vw;
        opacity: 0.5;
        font-family: monospace;
      }
      #main-msg {
        font-size: 6vh;
        margin-top: 20px;
        letter-spacing: 1vw;
        text-shadow: 0 4px 20px #000;
      }
    </style>
  </head>
  <body>
    <canvas id="bg-canvas"></canvas>
    <div id="flash-overlay"></div>
    <div id="slash-line"></div>

    <div id="game-container">
      <div class="player-zone" id="zone-p1">
        <div class="status-text" id="status-p1">PRESS & HOLD</div>
        <div class="instruction">P1 / SPACE</div>
      </div>

      <div class="player-zone" id="zone-p2">
        <div class="status-text" id="status-p2">PRESS & HOLD</div>
        <div class="instruction">P2 / ENTER</div>
      </div>
    </div>

    <div id="center-hud">
      <div class="score-board">
        <span id="score-p1">0</span> - <span id="score-p2">0</span>
      </div>
      <div id="main-msg"></div>
    </div>

    <script>
      /**
       * ==========================================================================
       * IAI ENGINE - Cinematic Samurai Duel Logic & Procedural Rendering
       * Zero Dependencies.
       * ==========================================================================
       */

      // --- CONFIGURATION ---
      const CFG = {
        chargeTime: 3000, // 蓄力总时长(ms)
        sweetSpotStart: 0.85, // 完美一闪起始区间 85%
        sweetSpotEnd: 0.95, // 完美一闪结束区间 95%
        winScore: 3,
        colors: {
          bg: "#050505",
          rain: "rgba(255,255,255,0.05)",
          blood: "#8a0303",
          ring: "#fff",
          ringDanger: "#c0392b",
        },
      };

      const STATE = {
        IDLE: 0,
        READYING: 1,
        CHARGING: 2,
        RESOLVING: 3,
        GAMEOVER: 4,
      };
      let gameState = STATE.IDLE;

      // 游戏核心变量
      let p1Ready = false,
        p2Ready = false;
      let p1Score = 0,
        p2Score = 0; // 0=未出手或失误, >0 为出手完美度
      let p1Committed = false,
        p2Committed = false;
      let chargeProgress = 0; // 0.0 to 1.0
      let chargeStartTime = 0;
      let wins = { p1: 0, p2: 0 };
      let shakeAmt = 0;

      // --- DOM 节点 ---
      const elStatusP1 = document.getElementById("status-p1");
      const elStatusP2 = document.getElementById("status-p2");
      const elZoneP1 = document.getElementById("zone-p1");
      const elZoneP2 = document.getElementById("zone-p2");
      const elMsg = document.getElementById("main-msg");

      // ================= 音效合成器 (Web Audio API) =================
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      let actx;
      let rainNode, rainGain, heartbeatNode, heartbeatGain;

      function initAudio() {
        if (actx && actx.state === "running") return;
        actx = new AudioCtx();

        // 1. 生成环境雨声 (白噪声低通滤波)
        const bufSize = actx.sampleRate * 2;
        const buffer = actx.createBuffer(1, bufSize, actx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
        rainNode = actx.createBufferSource();
        rainNode.buffer = buffer;
        rainNode.loop = true;

        const filter = actx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 400; // 沉闷的雨声

        rainGain = actx.createGain();
        rainGain.gain.value = 0.5;

        rainNode.connect(filter);
        filter.connect(rainGain);
        rainGain.connect(actx.destination);
        rainNode.start();

        // 2. 心跳发生器 (初始静音)
        heartbeatNode = actx.createOscillator();
        heartbeatNode.type = "sine";
        heartbeatNode.frequency.value = 45;
        heartbeatGain = actx.createGain();
        heartbeatGain.gain.value = 0;
        heartbeatNode.connect(heartbeatGain);
        heartbeatGain.connect(actx.destination);
        heartbeatNode.start();
      }

      const SFX = {
        // 触控确认音
        tap: () => {
          if (!actx) return;
          const osc = actx.createOscillator();
          const gain = actx.createGain();
          osc.type = "sine";
          osc.frequency.setValueAtTime(800, actx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            100,
            actx.currentTime + 0.1,
          );
          gain.gain.setValueAtTime(0.1, actx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + 0.1);
          osc.connect(gain);
          gain.connect(actx.destination);
          osc.start();
          osc.stop(actx.currentTime + 0.1);
        },
        // 出鞘/一闪 (极度凌厉)
        slash: () => {
          if (!actx) return;
          // 高频尖啸
          const osc = actx.createOscillator();
          const gain = actx.createGain();
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(2000, actx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            100,
            actx.currentTime + 0.3,
          );
          gain.gain.setValueAtTime(0.5, actx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + 0.3);
          osc.connect(gain);
          gain.connect(actx.destination);
          osc.start();
          osc.stop(actx.currentTime + 0.3);

          // 刀刃碰撞声 (噪音爆音)
          const bufSize = actx.sampleRate * 0.1;
          const buffer = actx.createBuffer(1, bufSize, actx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
          const noise = actx.createBufferSource();
          noise.buffer = buffer;
          const nFilter = actx.createBiquadFilter();
          nFilter.type = "highpass";
          nFilter.frequency.value = 1000;
          const nGain = actx.createGain();
          nGain.gain.setValueAtTime(0.8, actx.currentTime);
          nGain.gain.exponentialRampToValueAtTime(
            0.001,
            actx.currentTime + 0.1,
          );
          noise.connect(nFilter);
          nFilter.connect(nGain);
          nGain.connect(actx.destination);
          noise.start();
        },
        // 抢跑/走火音效 (沉闷的钝击)
        dullHit: () => {
          if (!actx) return;
          const osc = actx.createOscillator();
          const gain = actx.createGain();
          osc.type = "triangle";
          osc.frequency.setValueAtTime(150, actx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            40,
            actx.currentTime + 0.2,
          );
          gain.gain.setValueAtTime(0.4, actx.currentTime);
          gain.gain.linearRampToValueAtTime(0, actx.currentTime + 0.2);
          osc.connect(gain);
          gain.connect(actx.destination);
          osc.start();
          osc.stop(actx.currentTime + 0.2);
        },
      };

      let lastHeartbeatTime = 0;
      function triggerHeartbeatPulse(intensity) {
        // intensity 0 to 1
        if (!actx || intensity === 0) return;
        const now = actx.currentTime;
        const interval = 1.0 - intensity * 0.8; // 心跳越来越快 (1s -> 0.2s)

        if (now - lastHeartbeatTime > interval) {
          lastHeartbeatTime = now;
          heartbeatGain.gain.cancelScheduledValues(now);
          heartbeatGain.gain.setValueAtTime(0, now);
          heartbeatGain.gain.linearRampToValueAtTime(
            0.5 * intensity,
            now + 0.05,
          );
          heartbeatGain.gain.linearRampToValueAtTime(0, now + 0.2);

          // 手机震动心跳
          if (navigator.vibrate) navigator.vibrate(20);
        }
      }

      // ================= CANVAS 视觉渲染引擎 =================
      const canvas = document.getElementById("bg-canvas");
      const ctx = canvas.getContext("2d", { alpha: false });
      let width, height;

      class Drop {
        constructor() {
          this.reset(true);
        }
        reset(randomY = false) {
          this.x = Math.random() * width;
          this.y = randomY ? Math.random() * height : -10;
          this.length = Math.random() * 20 + 10;
          this.speed = Math.random() * 15 + 10;
          this.opacity = Math.random() * 0.3 + 0.1;
        }
        update() {
          this.y += this.speed;
          this.x -= 1; // 风向左倾斜
          if (this.y > height) this.reset();
        }
        draw(ctx) {
          ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x - 1, this.y + this.length);
          ctx.stroke();
        }
      }

      class BloodInk {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          const angle = Math.random() * Math.PI * 2;
          const force = Math.random() * 25 + 5;
          this.vx = Math.cos(angle) * force;
          this.vy = Math.sin(angle) * force;
          this.size = Math.random() * 15 + 2;
          this.life = 1.0;
          this.decay = Math.random() * 0.02 + 0.005;
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vx *= 0.85;
          this.vy *= 0.85; // 空气阻力极大，模拟水墨炸开
          this.vy += 0.5; // 重力滴落
          this.life -= this.decay;
          this.size *= 0.98;
        }
        draw(ctx) {
          if (this.life <= 0) return;
          ctx.fillStyle = CFG.colors.blood;
          ctx.globalAlpha = this.life;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
      }

      let drops = [];
      let inks = [];

      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        drops = [];
        for (let i = 0; i < 80; i++) drops.push(new Drop());
      }
      window.addEventListener("resize", resize);
      resize();

      function drawFocusRing() {
        if (gameState !== STATE.CHARGING) return;
        const cx = width / 2;
        const cy = height / 2;
        const maxRadius = Math.min(width, height) * 0.3;
        const radius = maxRadius * Math.pow(chargeProgress, 0.5); // 抛物线放大

        let ringColor = CFG.colors.ring;
        let lineWidth = 2;

        // 进入斩杀区间视觉突变
        if (
          chargeProgress >= CFG.sweetSpotStart &&
          chargeProgress <= CFG.sweetSpotEnd
        ) {
          ringColor = CFG.colors.ringDanger;
          lineWidth = 6;
          ctx.shadowBlur = 20;
          ctx.shadowColor = CFG.colors.ringDanger;
          shakeAmt = 5; // 屏幕颤抖
        } else if (chargeProgress > CFG.sweetSpotEnd) {
          ringColor = "#555"; // 过热碎裂预警
          lineWidth = 1;
          ctx.shadowBlur = 0;
        } else {
          ctx.shadowBlur = 10;
          ctx.shadowColor = "#fff";
        }

        ctx.strokeStyle = ringColor;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.arc(
          cx,
          cy,
          radius,
          -Math.PI / 2,
          -Math.PI / 2 + Math.PI * 2 * chargeProgress,
        );
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      function renderCanvas() {
        // 处理震动
        if (shakeAmt > 0) shakeAmt *= 0.8;
        const dx = (Math.random() - 0.5) * shakeAmt;
        const dy = (Math.random() - 0.5) * shakeAmt;

        ctx.setTransform(1, 0, 0, 1, dx, dy);

        // 刷除残影
        ctx.fillStyle = CFG.colors.bg;
        ctx.fillRect(-10, -10, width + 20, height + 20);

        drops.forEach((d) => {
          d.update();
          d.draw(ctx);
        });

        for (let i = inks.length - 1; i >= 0; i--) {
          inks[i].update();
          inks[i].draw(ctx);
          if (inks[i].life <= 0) inks.splice(i, 1);
        }

        drawFocusRing();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }

      // ================= 游戏核心状态机 =================

      function setUI(p1Txt, p2Txt, p1Class = "", p2Class = "", centerMsg = "") {
        elStatusP1.innerText = p1Txt;
        elStatusP1.className = `status-text ${p1Class}`;
        elStatusP2.innerText = p2Txt;
        elStatusP2.className = `status-text ${p2Class}`;
        elMsg.innerText = centerMsg;
      }

      function loop(timestamp) {
        if (gameState === STATE.CHARGING) {
          chargeProgress = (timestamp - chargeStartTime) / CFG.chargeTime;

          // 音效心跳与压迫感
          triggerHeartbeatPulse(Math.min(1, chargeProgress * 1.5));

          // 自动判定走火 (Overheat)
          if (chargeProgress > CFG.sweetSpotEnd) {
            if (!p1Committed) commitAction(1, true);
            if (!p2Committed) commitAction(2, true);
          }
        }

        renderCanvas();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      function startCharging() {
        if (gameState !== STATE.READYING) return;
        gameState = STATE.CHARGING;
        chargeProgress = 0;
        p1Score = 0;
        p2Score = 0;
        p1Committed = false;
        p2Committed = false;
        chargeStartTime = performance.now();
        setUI("", "", "", "", "");

        // 手机震动提示开始
        if (navigator.vibrate) navigator.vibrate(50);
      }

      function handlePress(player) {
        initAudio();
        if (gameState === STATE.GAMEOVER || gameState === STATE.RESOLVING)
          return;

        if (gameState === STATE.IDLE) {
          if (player === 1) {
            p1Ready = true;
            setUI(
              "READY",
              elStatusP2.innerText,
              "active",
              elStatusP2.classList.contains("active") ? "active" : "",
            );
          }
          if (player === 2) {
            p2Ready = true;
            setUI(
              elStatusP1.innerText,
              "READY",
              elStatusP1.classList.contains("active") ? "active" : "",
              "active",
            );
          }
          SFX.tap();

          if (p1Ready && p2Ready) {
            gameState = STATE.READYING;
            setTimeout(startCharging, 500); // 双双准备后，停顿0.5秒发球
          }
        }
      }

      function handleRelease(player) {
        if (gameState === STATE.IDLE || gameState === STATE.READYING) {
          // 取消准备
          if (player === 1) {
            p1Ready = false;
            setUI(
              "PRESS & HOLD",
              elStatusP2.innerText,
              "",
              elStatusP2.classList.contains("active") ? "active" : "",
            );
          }
          if (player === 2) {
            p2Ready = false;
            setUI(
              elStatusP1.innerText,
              "PRESS & HOLD",
              elStatusP1.classList.contains("active") ? "active" : "",
              "",
            );
          }
          return;
        }

        if (gameState === STATE.CHARGING) {
          commitAction(player, false);
        }
      }

      function commitAction(player, isAutoOverheat) {
        if (gameState !== STATE.CHARGING) return;
        if ((player === 1 && p1Committed) || (player === 2 && p2Committed))
          return;

        const actionProgress = Math.min(
          1,
          (performance.now() - chargeStartTime) / CFG.chargeTime,
        );
        let score = 0;
        let statusText = "";
        let isError = false;

        if (isAutoOverheat || actionProgress > CFG.sweetSpotEnd) {
          statusText = "BROKEN";
          isError = true;
          SFX.dullHit();
        } else if (actionProgress < CFG.sweetSpotStart) {
          statusText = "TOO EARLY";
          isError = true;
          SFX.dullHit();
        } else if (actionProgress <= CFG.sweetSpotEnd) {
          score = actionProgress; // 完美一闪！记录精度
          statusText = "STRIKE!";
          SFX.tap(); // 极其轻微的锁定音，给对方心理压力
        }

        if (player === 1) {
          p1Score = score;
          p1Committed = true;
          elStatusP1.innerText = statusText;
          elStatusP1.className = `status-text ${isError ? "error" : "active"}`;
        } else {
          p2Score = score;
          p2Committed = true;
          elStatusP2.innerText = statusText;
          elStatusP2.className = `status-text ${isError ? "error" : "active"}`;
        }

        // 如果双方都已判定，或一方完美另一方失误（直接结算）
        if (p1Committed && p2Committed) {
          resolveDuel();
        } else if (isError) {
          resolveDuel(player === 1 ? 2 : 1);
        }
      }

      function resolveDuel(forcedWinner = 0) {
        if (gameState === STATE.RESOLVING) return;
        gameState = STATE.RESOLVING;
        if (rainGain) rainGain.gain.setTargetAtTime(0.1, actx.currentTime, 0.5); // 雨声变小

        let winner = forcedWinner; // 0=Draw, 1=P1, 2=P2

        if (!winner) {
          if (p1Score > p2Score) winner = 1;
          else if (p2Score > p1Score) winner = 2;
          else winner = 0; // 精度完全一致的奇迹Draw
        }

        // 演出序列：屏息 -> 一闪 -> 结算
        setTimeout(() => {
          executeCinematic(winner);
        }, 400); // 0.4秒的“死寂”
      }

      function executeCinematic(winner) {
        // 1. 闪白与音效
        const flash = document.getElementById("flash-overlay");
        const slash = document.getElementById("slash-line");

        flash.classList.remove("anim-flash");
        void flash.offsetWidth;
        flash.classList.add("anim-flash");
        slash.classList.remove("anim-slash");
        void slash.offsetWidth;
        slash.classList.add("anim-slash");

        SFX.slash();
        if (navigator.vibrate) navigator.vibrate([100, 50, 100]); // 强烈震动

        // 2. 败者断裂与溅血
        if (winner === 1) {
          elZoneP2.classList.add("sliced-zone");
          spawnInk(width * 0.75, height / 2);
          wins.p1++;
          setUI("WINNER", "SLAIN", "active", "error");
        } else if (winner === 2) {
          elZoneP1.classList.add("sliced-zone");
          spawnInk(width * 0.25, height / 2);
          wins.p2++;
          setUI("SLAIN", "WINNER", "error", "active");
        } else {
          setUI("DRAW", "DRAW", "error", "error");
        }

        document.getElementById("score-p1").innerText = wins.p1;
        document.getElementById("score-p2").innerText = wins.p2;

        gameState = STATE.GAMEOVER;

        // 3. 重置循环
        setTimeout(() => {
          if (wins.p1 >= CFG.winScore || wins.p2 >= CFG.winScore) {
            elMsg.innerText =
              wins.p1 >= CFG.winScore ? "P1 IS THE MASTER" : "P2 IS THE MASTER";
            setTimeout(hardReset, 4000);
          } else {
            resetRound();
          }
        }, 2500);
      }

      function spawnInk(x, y) {
        for (let i = 0; i < 60; i++) inks.push(new BloodInk(x, y));
      }

      function resetRound() {
        gameState = STATE.IDLE;
        p1Ready = p2Ready = false;
        elZoneP1.classList.remove("sliced-zone");
        elZoneP2.classList.remove("sliced-zone");
        setUI("PRESS & HOLD", "PRESS & HOLD");
        if (rainGain) rainGain.gain.setTargetAtTime(0.5, actx.currentTime, 1);
      }

      function hardReset() {
        wins = { p1: 0, p2: 0 };
        document.getElementById("score-p1").innerText = 0;
        document.getElementById("score-p2").innerText = 0;
        elMsg.innerText = "";
        resetRound();
      }

      // ================= 输入绑定 =================
      const bindHold = (el, player) => {
        el.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            handlePress(player);
          },
          { passive: false },
        );
        el.addEventListener("touchend", (e) => {
          e.preventDefault();
          handleRelease(player);
        });
        el.addEventListener("mousedown", (e) => {
          handlePress(player);
        });
        window.addEventListener("mouseup", (e) => {
          handleRelease(player);
        }); // 全局释放防卡键
      };
      bindHold(elZoneP1, 1);
      bindHold(elZoneP2, 2);

      const keys = {};
      window.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        keys[e.code] = true;
        if (e.code === "Space") handlePress(1);
        if (e.code === "Enter" || e.code === "NumpadEnter") handlePress(2);
      });
      window.addEventListener("keyup", (e) => {
        keys[e.code] = false;
        if (e.code === "Space") handleRelease(1);
        if (e.code === "Enter" || e.code === "NumpadEnter") handleRelease(2);
      });

      // 阻止默认上下文菜单
      window.addEventListener("contextmenu", (e) => e.preventDefault());
    </script>
  </body>
</html>
